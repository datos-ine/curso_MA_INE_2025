<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Regresión logística – Unidad 4</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>
<style type="text/css">
.quarto-reader-toggle .bi::before, .quarto-color-scheme-toggle .bi::before {
  display: inline-block;
  height: 40px;
  width: 40px;
  background-size: 25px 25px;
  background-position: center;
  background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="rgba(189, 195, 199, 1)" class="bi bi-moon-stars-fill" viewbox="0 0 16 16"> <path d="M6 .278a.77.77 0 0 1 .08.858 7.2 7.2 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277q.792-.001 1.533-.16a.79.79 0 0 1 .81.316.73.73 0 0 1-.031.893A8.35 8.35 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.75.75 0 0 1 6 .278"></path> <path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.73 1.73 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.73 1.73 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.73 1.73 0 0 0 1.097-1.097zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.16 1.16 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.16 1.16 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732z"></path> </svg>') !important;
}
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./reg_logistica.html">Regresión logística</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Buscar" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
      <a href="https://ine.gov.ar/" class="sidebar-logo-link">
      <img src="./images/logos_ine.svg" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Alternar modo oscuro"><i class="bi"></i></a>
</div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Unidad 4: Estudios de casos y controles</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./reg_logistica.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Regresión logística</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contenidos</h2>
   
  <ul>
  <li><a href="#introducción" id="toc-introducción" class="nav-link active" data-scroll-target="#introducción">Introducción</a></li>
  <li><a href="#modelos-lineales-generalizados" id="toc-modelos-lineales-generalizados" class="nav-link" data-scroll-target="#modelos-lineales-generalizados">Modelos lineales generalizados</a></li>
  <li><a href="#componentes-del-modelo-logístico" id="toc-componentes-del-modelo-logístico" class="nav-link" data-scroll-target="#componentes-del-modelo-logístico">Componentes del modelo logístico</a>
  <ul class="collapse">
  <li><a href="#test-de-wald" id="toc-test-de-wald" class="nav-link" data-scroll-target="#test-de-wald">Test de Wald</a></li>
  <li><a href="#máxima-verosimilitud" id="toc-máxima-verosimilitud" class="nav-link" data-scroll-target="#máxima-verosimilitud">Máxima verosimilitud</a></li>
  <li><a href="#deviance" id="toc-deviance" class="nav-link" data-scroll-target="#deviance"><em>Deviance</em></a></li>
  <li><a href="#likelihood-ratio-test" id="toc-likelihood-ratio-test" class="nav-link" data-scroll-target="#likelihood-ratio-test"><em>Likelihood Ratio Test</em></a></li>
  <li><a href="#criterio-de-información-de-akaike" id="toc-criterio-de-información-de-akaike" class="nav-link" data-scroll-target="#criterio-de-información-de-akaike">Criterio de Información de Akaike</a></li>
  <li><a href="#bondad-de-ajuste" id="toc-bondad-de-ajuste" class="nav-link" data-scroll-target="#bondad-de-ajuste">Bondad de ajuste</a></li>
  <li><a href="#capacidad-predictiva-del-modelo" id="toc-capacidad-predictiva-del-modelo" class="nav-link" data-scroll-target="#capacidad-predictiva-del-modelo">Capacidad predictiva del modelo</a></li>
  </ul></li>
  <li><a href="#construcción-del-modelo-en-r" id="toc-construcción-del-modelo-en-r" class="nav-link" data-scroll-target="#construcción-del-modelo-en-r">Construcción del modelo en R</a>
  <ul class="collapse">
  <li><a href="#gestión-de-variables-dicotómicas" id="toc-gestión-de-variables-dicotómicas" class="nav-link" data-scroll-target="#gestión-de-variables-dicotómicas">Gestión de variables dicotómicas</a></li>
  <li><a href="#ajuste-del-modelo" id="toc-ajuste-del-modelo" class="nav-link" data-scroll-target="#ajuste-del-modelo">Ajuste del modelo</a></li>
  </ul></li>
  </ul>
<div class="quarto-other-links"><h2>Otros Enlaces</h2><ul><li><a href="http://capacitacion.anlis.gob.ar/"><i class="bi bi-tag-fill"></i>Plataforma Educativa ANLIS</a></li><li><a href="https://github.com/datos-ine/unidad_4"><i class="bi bi-github"></i>Github</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Regresión logística</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>

<center>
Este material es parte de la Unidad 4 del curso de Epidemiología - Nivel Avanzado <br> © 2025 Instituto Nacional de Epidemiología “Dr.&nbsp;Juan H. Jara” (ANLIS) - <a href="http://creativecommons.org/licenses/by-nc/4.0/?ref=chooser-v1"> CC BY-NC 4.0 </a> <img src="images/cc01.svg" class="img-fluid" style="width:3.0%"> <img src="images/cc02.svg" class="img-fluid" style="width:3.0%"> <img src="images/cc03.svg" class="img-fluid" style="width:3.0%"> <br> <br>
</center>
<section id="introducción" class="level2">
<h2 class="anchored" data-anchor-id="introducción">Introducción</h2>
<p>Cuando la variable dependiente es dicotómica o binaria, es decir, tiene dos categorías mutuamente excluyentes (éxito/fracaso; sí/no; positivo/negativo, etc.), los modelos de regresión lineal no son el abordaje más adecuado para el análisis. Consideremos un evento de salud que puede ocurrir o no (variable dependiente). Por ejemplo:</p>
<ul>
<li><p>Un paciente hospitalizado muere/no muere antes del alta.</p></li>
<li><p>Un niño nace con/sin una malformación congénita.</p></li>
<li><p>Un sujeto operado se infecta/no se infecta en el postoperatorio.</p></li>
<li><p>Un niño camina/no camina a los 11 meses.</p></li>
<li><p>Una droga mejora/no mejora los síntomas depresivos.</p></li>
</ul>
<p>Teniendo en cuenta que nuestra variable respuesta es dicotómica:</p>
<p><span class="math display">\[
Y = 1 \rightarrow Si~el~hecho~ocurre \\
Y  = 0 \rightarrow Si~el~hecho~no~ocurre
\]</span></p>
<p>Si representáramos los datos con una función lineal, obtendríamos el siguiente gráfico:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="reg_logistica_files/figure-html/plot1-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:85.0%"></p>
</figure>
</div>
</div>
</div>
<p>Matemáticamente, la función exponencial representa mejor esta relación:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="reg_logistica_files/figure-html/plot2-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:85.0%"></p>
</figure>
</div>
</div>
</div>
<p>La <strong>regresión logística</strong> se utiliza en los casos en que la variable dependiente es binaria, mientras que las variables independientes pueden ser de cualquier tipo (categóricas, dicotómicas, numéricas discretas o continuas). En vez de la ecuación de la recta, ahora tenemos otra ecuación que expresa la variable respuesta (<span class="math inline">\(Y\)</span>) en función de la/las variables independientes. Esta ecuación, en realidad, expresa la probabilidad de que ocurra un hecho en función de ciertas variables que se presumen relevantes.</p>
<p>La expresión analítica es:</p>
<p><span class="math display">\[
P(Y=1)_x=\frac{1}{1+e^{(-\alpha-\beta_1X_1-\beta_2X_2-\dots-\beta_kX_k)}}
\]</span></p>
<p>Para comprender lo que significan los coeficientes <span class="math inline">\(\beta\)</span> del modelo, vamos a hacer algunas operaciones matemáticas. Comenzaremos por realizar una transformación logística, es decir, dividir ambos miembros de la ecuación por <span class="math inline">\(1-P_{(Y=1)}\)</span>:</p>
<p><span class="math display">\[
\frac{P(Y=1)_x}{1-P(Y=1)_x}=\frac{\frac{1}{1+e^{(-\alpha-\beta_1X_1-\beta_2X_2-\dots-\beta_kX_k)}}}{1-\frac{1}{1+e^{(-\alpha-\beta_1X_1-\beta_2X_2-\dots-\beta_kX_k)}} }
\]</span></p>
<p>Si ahora aplicamos logaritmo natural (<span class="math inline">\(ln\)</span>) a ambos miembros de la ecuación, y aplicamos propiedades de los logaritmos, nos queda:</p>
<p><span class="math display">\[
ln\bigg[\frac{P_x}{1-P_x}\bigg] = \alpha + \sum\beta_ix_i
\]</span></p>
<p>Si observamos el término que está entre corchetes, recordaremos que el cociente entre la probabilidad que un suceso ocurra, y la probabilidad de que no ocurra, es lo que conocemos como <em>Odds</em>, entonces:</p>
<p><span class="math display">\[
ln(Odds) = \alpha+\sum\beta_ix_i
\]</span></p>
<p>Si despejamos <em>Odds</em> de la ecuación anterior, podemos concluir entonces que:</p>
<p><span class="math display">\[
Odds = e^{(\alpha+\sum\beta_ix_i)}
\]</span></p>
<p>Para comprender mejor cómo se interpretarán los coeficientes en la regresión logística, supongamos que queremos modelar la probabilidad de que un evento ocurra, <span class="math inline">\(P_{(Y=1)}\)</span>, en función de una única variable independiente dicotómica, que toma el valor 0 cuando la condición está ausente (<span class="math inline">\(x=0\)</span>) y el valor 1 cuando está presente (<span class="math inline">\(x=1\)</span>). Entonces:</p>
<p>Para <span class="math inline">\(x=1\)</span></p>
<p><span class="math display">\[
Odds_{evento/expuestos}=e^{(\alpha+\beta)}
\]</span></p>
<p>Para <span class="math inline">\(x=0\)</span></p>
<p><span class="math display">\[
Odds_{evento/expuestos}=e^{(\alpha)}
\]</span></p>
<p>Entonces, si queremos calcular el <em>odds-ratio</em> (OR):</p>
<p><span class="math display">\[
OR = \frac{e^{(\alpha+\beta)}}{e^\alpha}=e^\beta
\]</span></p>
<p>Por lo tanto:</p>
<p><span class="math display">\[
ln\; OR = \beta
\]</span></p>
<p>De esta forma, vemos que <span class="math inline">\(\beta\)</span> = incremento del logaritmo del OR por cada unidad de incremento de <span class="math inline">\(x\)</span>.</p>
<p>Extendiendo el razonamiento para la regresión logística múltiple, es decir cuando modelamos en función de más de una variable independiente, volvemos a la ecuación:</p>
<p><span class="math display">\[
ln(Odds) = \alpha + \sum\beta_ix_i
\]</span></p>
<p>Donde cada <span class="math inline">\(\beta_i\)</span>: Incremento en log-odds para una unidad de incremento en <span class="math inline">\(x_i\)</span> con todas las otras <span class="math inline">\(x_i\)</span> constantes.</p>
<p>Incluimos esta deducción para facilitar la comprensión del tema, pero para quienes el lenguaje matemático les es adverso, pueden hacer un <em>“acto de fe”</em> y quedarse con las conclusiones.</p>
</section>
<section id="modelos-lineales-generalizados" class="level2">
<h2 class="anchored" data-anchor-id="modelos-lineales-generalizados">Modelos lineales generalizados</h2>
<p>La regresión logística forma parte de la familia de modelos lineales generalizados (GLM por su nombre en inglés, <em>Generalized Linear Models</em>), utilizados para predecir la probabilidad de que ocurra un evento binario (como infectado/no infectado, enfermo/no enfermo, sobreviviente/fallecido, etc.) en función de una o más variables independientes. Los GLM extienden los modelos de regresión lineales al permitir el uso de distribuciones no normales de errores (como binomiales, Poisson, gamma, entre otras) y varianzas no constantes. Estos modelos se caracterizan por una estructura de errores específica y una función de enlace que conecta la variable respuesta con la(s) variable(s) independiente(s).</p>
<p>En el caso de la regresión logística, donde la variable respuesta es binaria (0, 1), la estructura de errores pertenece a la familia de distribución <em>binomial</em>. La función de enlace típica para linealizar la relación entre la variable respuesta y la(s) variable(s) independiente(s) es la función <em>logit</em>, que es el logaritmo natural del odds-ratio (OR). Esta función de enlace transforma la escala de probabilidades (de 0 a 1) a una escala lineal (de <span class="math inline">\(-\infty\)</span> a <span class="math inline">\(+\infty\)</span>), lo que facilita la modelización de la relación entre las variables independientes y la variable respuesta binaria.</p>
</section>
<section id="componentes-del-modelo-logístico" class="level2">
<h2 class="anchored" data-anchor-id="componentes-del-modelo-logístico">Componentes del modelo logístico</h2>
<p>Al igual que en la regresión lineal múltiple (RLM), antes de adentrarnos en el modelado, exploraremos cómo interpretar la salida de R para un modelo de regresión logística obtenida a partir de la función <code>summary(modelo)</code>:</p>
<div class="cell" data-layout-align="center">
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
glm(formula = y ~ x1 + x2, family = binomial, data = datos)

Coefficients:
            Estimate Std. Error z value Pr(&gt;|z|)    
(Intercept)  -0.3362     0.2816  -1.194   0.2325    
x1B           0.4267     0.4012   1.064   0.2875    
x1C           0.7016     0.3996   1.756   0.0791 .  
x2            1.2669     0.2103   6.023 1.71e-09 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 277.08  on 199  degrees of freedom
Residual deviance: 221.48  on 196  degrees of freedom
AIC: 229.48

Number of Fisher Scoring iterations: 4</code></pre>
</div>
</div>
<p>Los elementos a tener en cuenta son:</p>
<ul>
<li><p><strong>Call</strong>: Muestra la fórmula del modelo utilizado.</p></li>
<li><p><strong>Estimate</strong>: Contiene los coeficientes <span class="math inline">\(\beta\)</span> estimados, incluyendo el intercepto (<span class="math inline">\(\beta_0\)</span>) y las variables explicativas (<span class="math inline">\(\beta_i\)</span>). Al aplicar a estos coeficientes la función <code>exp()</code>, que representa la función inversa del logaritmo natural, se obtiene el Odds Ratio (OR). Esto implica que los coeficientes de las variables independientes se interpretan como el OR de que ocurra el evento para cada incremento de la variable independiente, manteniendo constantes las demás variables independientes.</p></li>
<li><p><strong>Std. Error</strong>: Representa el error estándar asociado a cada coeficiente.</p></li>
<li><p><strong>z value</strong>: Corresponde al estadístico del test de Wald para evaluar la significancia de cada coeficiente.</p></li>
<li><p><strong>Pr(&gt;|z|)</strong>: Proporciona los <em>p</em>-valores asociados al test de Wald, que indican si los coeficientes son significativamente diferentes de cero.</p></li>
</ul>
<p>Además, en la parte final de la salida se presentan:</p>
<ul>
<li><p><strong>Null deviance</strong>: La devianza del modelo nulo, que asume que ninguna de las variables explicativas tiene efecto.</p></li>
<li><p><strong>Residual deviance</strong>: La devianza del modelo ajustado, que indica cuánto se reduce la devianza al incluir las variables explicativas.</p></li>
<li><p><strong>AIC (Criterio de Información de Akaike)</strong>: Una medida de la calidad del modelo, penalizando por la complejidad para favorecer modelos más parsimoniosos.</p></li>
<li><p><strong>Number of Fisher Scoring iterations</strong>: Número de iteraciones realizadas durante el proceso de estimación de parámetros del modelo.</p></li>
</ul>
<p>A continuación, profundizaremos en el significado de algunos de estos conceptos.</p>
<section id="test-de-wald" class="level3">
<h3 class="anchored" data-anchor-id="test-de-wald">Test de Wald</h3>
<p>El test de Wald se utiliza para evaluar la significación de una variable dentro del modelo. De manera similar al test <span class="math inline">\(F\)</span> parcial en la regresión lineal múltiple, este test contrasta la hipótesis nula:</p>
<p><span class="math display">\[
H_0 : \beta_i = 0
\]</span></p>
<p>Expresamos la prueba en términos del coeficiente <span class="math inline">\(\beta_i\)</span> porque esta formulación es análoga a la utilizada en regresión lineal. Sin embargo, en regresión logística, los resultados suelen presentarse en términos de <em>odds-ratio</em> (OR).</p>
<p>Dado que una pendiente <span class="math inline">\(\beta_i = 0\)</span> implica un OR de 1, la hipótesis nula también puede expresarse como <em>“la razón de probabilidades es 1”</em>. Esto significa que la variable explicativa no tiene capacidad predictiva, ya que las probabilidades de los grupos comparados son iguales.</p>
<p>La interpretación sigue criterios comunes en inferencia estadística: valores de <em>p</em> menores a 0,05 sugieren evidencia suficiente para rechazar la hipótesis nula, indicando que la variable contribuye significativamente al modelo (<em>p</em> &lt; 0,1 podría considerarse en contextos más flexibles). Es fundamental recordar que, en regresión logística, los coeficientes <span class="math inline">\(\beta_i\)</span> no se interpretan directamente. Para obtener su efecto sobre la razón de probabilidades, se debe calcular su exponencial <span class="math inline">\(\exp(\beta_i)\)</span>.</p>
</section>
<section id="máxima-verosimilitud" class="level3">
<h3 class="anchored" data-anchor-id="máxima-verosimilitud">Máxima verosimilitud</h3>
<p>Mientras que en la regresión lineal múltiple (RLM) los coeficientes <span class="math inline">\(\beta\)</span> se obtenían por el método de los mínimos cuadrados, en la regresión logística (RLOG) se obtienen mediante el método de máxima verosimilitud (ML, por su nombre en inglés, <em>Maximum Likelihood</em>). El fundamento de esta técnica radica en utilizar la información disponible de los datos de la muestra para seleccionar el valor del parámetro que maximiza la probabilidad de observar los resultados muestrales. La ML, entonces, se calcula mediante un proceso iterativo.</p>
<p>Por lo tanto, una medida adecuada para evaluar la concordancia del modelo con los datos sería el producto de todas las probabilidades (predichas por el modelo), que los <span class="math inline">\(n\)</span> sujetos de la muestra realmente tengan la condición observada. Es decir, un buen modelo sería el que asigne una probabilidad de 1 (<span class="math inline">\(p = 1\)</span>) a cada sujeto que realmente tenga la condición y de 0 (<span class="math inline">\(p = 0\)</span>) a cada sujeto libre de ella, correspondiendo a una ML de 1. Por el contrario, un modelo deficiente tendría una verosimilitud cercana a 0. En consecuencia, la proximidad de la verosimilitud a 1 expresa cuán eficiente ha sido el ajuste realizado para modelar la realidad.</p>
</section>
<section id="deviance" class="level3">
<h3 class="anchored" data-anchor-id="deviance"><em>Deviance</em></h3>
<p>La <em>deviance</em> (<span class="math inline">\(D\)</span>), también conocida como devianza o distancia, se define como:</p>
<p><span class="math display">\[
D = -2lnV
\]</span></p>
<p>Donde <span class="math inline">\(V\)</span> es la verosimilitud del modelo.</p>
<p>Dado que, como explicamos anteriormente, <span class="math inline">\(V &lt; 1\)</span>, su logaritmo siempre será negativo, haciendo que la devianza sea siempre un número positivo. El grado de ajuste de un modelo será mejor cuanto más próxima a 1 es la verosimilitud y, en consecuencia, cuanto más cercana a cero sea la devianza.</p>
<p>Al ajustar el modelo se calculan dos devianzas: la correspondiente al <em>“modelo nulo”</em> (<span class="math inline">\(D_0\)</span>), que es aquel en que no se ha incorporado ninguna variable independiente, y la <span class="math inline">\(D_f\)</span> del modelo. La diferencia (o cociente) entre estas dos devianzas mide la “contribución” que hacen las variables incorporadas al modelo:</p>
<p><span class="math display">\[
-2lnV_0 - (-2lnV_f)
\]</span></p>
<p>La <span class="math inline">\(D_0\)</span> es siempre mayor que la de cualquier modelo ampliado. Esto es razonable, ya que el modelo nulo es mucho menos complejo (no incorpora información de variables “explicativas”) y, por lo tanto, tendrá una capacidad predictiva inferior.</p>
</section>
<section id="likelihood-ratio-test" class="level3">
<h3 class="anchored" data-anchor-id="likelihood-ratio-test"><em>Likelihood Ratio Test</em></h3>
<p>El <em>Likelihood Ratio Test</em> (LRT) compara la probabilidad de los datos observados bajo dos modelos: uno que incluye los predictores y otro que no. Para ello, evalúa la diferencia en los residuos entre ambos modelos, lo que equivale a comparar sus respectivas <em>devianzas</em> (<span class="math inline">\(D\)</span>).</p>
<p><span class="math display">\[
D_0 - D = -2lnV_0 + 2lnV = -2ln(V_0-V) = -2ln\bigg(\frac{V_0}{V}\bigg)  \]</span></p>
<p>Donde <span class="math inline">\(\frac{V_0}{V}\)</span> es el <em>Likelihood Ratio</em> o razón de verosimilitud.</p>
<p>El LRT permite evaluar la significancia de la incorporación de predictores al modelo, comparándolo con el modelo nulo (sin predictores).El estadístico de prueba sigue una distribución <span class="math inline">\(\chi^2\)</span> con grados de libertad equivalentes al número de predictores incluidos en el modelo.</p>
<p>En términos prácticos, la <em>razón de verosimilitud</em> se obtiene al comparar las <em>devianzas</em> de dos modelos, uno con más y otro con menos predictores. Esto permite determinar si la inclusión de ciertas variables mejora significativamente el ajuste del modelo. En la salida de un modelo, los valores de devianza aparecen bajo los títulos <code>Null deviance</code> (para el modelo nulo) y <code>Residual deviance</code> (para el modelo con predictores).</p>
</section>
<section id="criterio-de-información-de-akaike" class="level3">
<h3 class="anchored" data-anchor-id="criterio-de-información-de-akaike">Criterio de Información de Akaike</h3>
<p>El Criterio de Información de Akaike (AIC) es una medida de la calidad relativa de un modelo estadístico, para un conjunto dado de datos. Se define como:</p>
<p><span class="math display">\[
AIC= 2k – 2ln(D)
\]</span></p>
<p>Donde,</p>
<ul>
<li><p><span class="math inline">\(k\)</span>: número de parámetros del modelo.</p></li>
<li><p><span class="math inline">\(D\)</span>: devianza del modelo.</p></li>
</ul>
<p>El AIC proporciona un método para la selección de modelos, donde valores menores de AIC indican un mejor ajuste del modelo a los datos.</p>
<div class="callout callout-style-simple callout-warning">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Para comparar dos o más modelos de regresión logística, se pueden utilizar las siguientes técnicas:</p>
<ul>
<li><p><strong>AIC</strong>: El primer término de la ecuación del AIC penaliza por la inclusión de variables en el model (<span class="math inline">\(2k\)</span>), mientras que el segundo compensa por la bondad de ajuste (<span class="math inline">\(2ln(D)\)</span>). Por lo tanto, dado un conjunto de modelos para los datos, el modelo preferido es aquel con el valor mínimo de AIC.</p>
<p>En R, realizamos la comparación con la función <code>AIC()</code>:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Genero modelo más sencillo</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>mod2 <span class="ot">&lt;-</span> <span class="fu">update</span>(modelo, <span class="sc">~</span>.<span class="sc">-</span>x1)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Comparo AIC</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="fu">AIC</span>(modelo, mod2)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>       df      AIC
modelo  4 229.4788
mod2    2 228.6598</code></pre>
</div>
</div></li>
<li><p><strong><em>Likelihood Ratio Test:</em></strong> Este test permite comparar dos modelos evaluando la significancia de la diferencia de devianzas. El estadístico tiene una distribución <span class="math inline">\(\chi^2\)</span> con grados de libertad iguales a la diferencia en el número de parámetros entre los dos modelos comparados.</p>
<p>La función <code>anova()</code> del paquete <code>stats</code> permite comparar modelos por si diferencia de varianzas:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">anova</span>(modelo, mod2, <span class="at">test =</span> <span class="st">"Chisq"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Analysis of Deviance Table

Model 1: y ~ x1 + x2
Model 2: y ~ x2
  Resid. Df Resid. Dev Df Deviance Pr(&gt;Chi)
1       196     221.48                     
2       198     224.66 -2  -3.1811   0.2038</code></pre>
</div>
</div>
<p>También podemos usar la función <code>test_lrt()</code> del paquete <code>performance</code>:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">test_lrt</span>(modelo, mod2)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># Likelihood-Ratio-Test (LRT) for Model Comparison (ML-estimator)

Name   | Model | df | df_diff | Chi2 |     p
--------------------------------------------
modelo |   glm |  4 |         |      |      
mod2   |   glm |  2 |      -2 | 3.18 | 0.204</code></pre>
</div>
</div></li>
</ul>
</div>
</div>
</div>
</section>
<section id="bondad-de-ajuste" class="level3">
<h3 class="anchored" data-anchor-id="bondad-de-ajuste">Bondad de ajuste</h3>
<p>De forma análoga al Coeficiente de Determinación (<span class="math inline">\(R^2\)</span>) utilizado en regresión Lineal, se han desarrollado diversos coeficientes para estimar la proporción de variabilidad explicada por las variables independientes en modelos de regresión logística.</p>
<p>En R, podemos calcular estos coeficientes utilizando el paquete <code>performance</code>:</p>
<ul>
<li><p><strong>Coeficiente de McFadden:</strong> Es una de las medidas más utilizadas y se interpreta de manera similar al <span class="math inline">\(R^2\)</span> en regresión lineal:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">r2_mcfadden</span>(modelo)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># R2 for Generalized Linear Regression
       R2: 0.201
  adj. R2: 0.193</code></pre>
</div>
</div></li>
<li><p><strong>Coeficiente de Cox y Snell:</strong> Se basa en la razón de verosimilitud y es una generalización del <span class="math inline">\(R^2\)</span> en modelos lineales:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">r2_coxsnell</span>(modelo)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Cox &amp; Snell's R2 
       0.2427035 </code></pre>
</div>
</div></li>
<li><p><strong>Coeficiente de Nagelkerke:</strong> El coeficiente de Nagelkerke es una versión corregida del coeficiente de Cox y Snell, cuyo valor máximo es menor a 1 incluso para un modelo perfecto, corrigiendo así la tendencia de subestimación del coeficiente <span class="math inline">\(R^2\)</span>.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">r2_nagelkerke</span>(modelo)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Nagelkerke's R2 
      0.3237019 </code></pre>
</div>
</div></li>
<li><p><strong>Coeficiente de Tjur:</strong> Calcula el Coeficiente de Discriminación (<span class="math inline">\(D\)</span>) para modelos lineales generalizados con variable respuesta binaria. Es el proporcionado por defecto para modelos de regresión logística en <code>performance</code>:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">r2</span>(modelo)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># R2 for Logistic Regression
  Tjur's R2: 0.251</code></pre>
</div>
</div></li>
<li><p><strong>Test de Hosmer-Lemeshow</strong>: Ninguno de los coeficientes anteriores mide directamente la calidad del ajuste del modelo. Para evaluar esto, utilizamos el <strong>test de Hosmer-Lemeshow</strong>, que compara las probabilidades predichas con las observadas.</p>
<p>Este test calcula un estadístico de distribución <span class="math inline">\(\chi^2\)</span> con <span class="math inline">\(n-2\)</span> grados de libertad, utilizando varios grupos basados en los deciles de las probabilidades predichas. En R:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">performance_hosmer</span>(modelo)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># Hosmer-Lemeshow Goodness-of-Fit Test

  Chi-squared: 12.091
           df:  8    
      p-value:  0.147</code></pre>
</div>
</div>
<p>En un test de bondad de ajuste, la hipótesis nula siempre afirma que el modelo propuesto se ajusta bien a los datos observados. Por lo tanto, un <em>p</em>-valor superior a 0.05 implica que lo observado se ajusta suficientemente bien a lo esperado bajo el modelo.</p></li>
</ul>
</section>
<section id="capacidad-predictiva-del-modelo" class="level3">
<h3 class="anchored" data-anchor-id="capacidad-predictiva-del-modelo">Capacidad predictiva del modelo</h3>
<p>Otro aspecto a evaluar en un modelo de RLOG es su capacidad de <em>discriminación</em>, es decir, la habilidad del modelo para distinguir entre individuos en los que ocurre el evento y aquellos en los que no. Una medida común de esta discriminación es el área bajo la <strong>curva ROC</strong> (<em>Receiver Operating Characteristic</em>), que se construye utilizando las probabilidades predichas por el modelo.</p>
<p>Para evaluar la efectividad del modelo en la clasificación de observaciones, se puede construir una tabla de clasificación que cruza el verdadero valor de la observación (1 o 0) con la predicción del modelo. Como el modelo de RLOG estimará probabilidades en el rango de 0 a 1, tendremos que elegir un punto de corte en forma arbitraria. Por ejemplo, podríamos decidir que probabilidades estimadas mayores a 0.5 sean indicativas de que el evento ha ocurrido, mientras que probabilidades menores o iguales a 0.5 indiquen que el evento no ha ocurrido.</p>
<p>La capacidad predictiva de un modelo de regresión logística se resume utilizando los conceptos de sensibilidad y especificidad. Quienes trabajen en áreas relacionadas al diagnóstico estarán más familiarizados con estos conceptos.</p>
<ul>
<li><p><strong>Sensibilidad:</strong> Probabilidad de que el modelo prediga correctamente que el evento ha ocurrido cuando <em>realmente</em> <em>ha ocurrido</em>.</p>
<p><span class="math display">\[
P(\hat{y} = 1|y = 1)
\]</span></p></li>
<li><p><strong>Especificidad:</strong> Probabilidad de que el modelo prediga correctamente que el evento no ha ocurrido cuando <em>realmente no ha ocurrido</em>.</p></li>
</ul>
<p><span class="math display">\[
P(\hat{y}=0|y=0)
\]</span></p>
<p>La curva ROC es un gráfico que representa la sensibilidad en función de 1 menos la especificidad. Si vamos modificando los valores del valor de corte y representamos la <strong>sensibilidad</strong> (en el eje Y) frente a <strong>1 – especificidad</strong> (en el eje X) tenemos la curva ROC. Cuanto mayor sea el área bajo esta curva, mejores serán las predicciones del modelo.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="reg_logistica_files/figure-html/roc-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:85.0%"></p>
</figure>
</div>
</div>
</div>
<p>Esta curva representa, para todos los pares posibles de individuos formados por uno en el que ocurrió el evento y otro en el que no, la proporción de aquellos para los cuales el modelo predice una mayor probabilidad de haber experimentado el evento.</p>
<div class="callout callout-style-simple callout-caution">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>Para evaluar un modelo de RLOG deberíamos observar:</p>
<ul>
<li><strong>Coeficientes de determinación</strong> : Variabilidad explicada por el modelo.</li>
<li><strong>Test de Hosmer‐Lemeshow</strong>: Bondad de ajuste, diferencia entre los valores predichos por el modelo y los valores observados en la muestra.</li>
<li><strong>AIC</strong>, <strong>LRT</strong> o <strong>ANOVA</strong>: Comparación de modelos.</li>
<li><strong>Curva ROC</strong>: Capacidad predictiva (especialmente cuando el propósito es predictivo).</li>
<li><strong>Intervalos de confianza</strong>: Exactitud del coeficiente.</li>
</ul>
</div>
</div>
</div>
</section>
</section>
<section id="construcción-del-modelo-en-r" class="level2">
<h2 class="anchored" data-anchor-id="construcción-del-modelo-en-r">Construcción del modelo en R</h2>
<p>El ajuste de un modelo de regresión logística en R se realiza utilizando la función <code>glm()</code>, del paquete <code>stats</code>:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">glm</span>(formula, <span class="at">family =</span> <span class="fu">binomial</span>(<span class="at">link =</span> <span class="st">"logit"</span>), data)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li><strong>Formula:</strong> Especifica la relación entre la variable dependiente y las variables independientes en el modelo. Sigue la estructura estándar:</li>
</ul>
<p><span class="math display">\[
variable\_dependiente \sim variable\_indep_1 + variable\_indep_2 +\dots+ variable\_indep_n
\]</span></p>
<ul>
<li><p><strong>Family:</strong> Se refiere a la familia de distribuciones y la función de enlace utilizada para ajustar el modelo. Las opciones comunes incluyen:</p>
<ul>
<li><p><code>gaussian()</code>: Utilizada para variables dependientes continuas con distribución normal. El enlace predeterminado es <code>identity</code>, lo cual es análogo a ajustar un modelo de RLM. Puede emplear también enlaces <code>log</code>, e <code>inverse</code>.</p></li>
<li><p><code>binomial()</code>: Utilizada para variables dependientes binarias (0, 1). El enlace predeterminado es <code>logit</code>, que es el más común en la regresión logística. También admite enlaces como <code>probit</code>, <code>cauchit</code>, <code>log</code>, y <code>cloglog</code>.</p></li>
<li><p><code>poisson()</code>: Usada para variables dependientes numéricas discretas. El enlace predeterminado es el logaritmo (<code>log)</code>, y también admite <code>identity</code> y <code>sqrt</code>.</p></li>
<li><p>Otras familias como <code>Gamma()</code>, <code>inverse.gaussian()</code>, <code>quasi()</code>, <code>quasipoisson()</code>, y <code>quasibinomial()</code> para diferentes distribuciones de errores que no abordaremos en el curso.</p></li>
</ul>
<p>Si la función de enlace no se especifica, se utiliza el enlace canónico (predeterminado) para cada familia. Por ejemplo, si omitimos el argumento <code>link = "logit"</code>, de todas maneras quedaría definido ese mismo enlace para la familia <code>binomial</code>.</p></li>
<li><p><strong>Data:</strong> Nombre del dataframe que contiene las variables utilizadas en el modelo.</p></li>
</ul>
<section id="gestión-de-variables-dicotómicas" class="level3">
<h3 class="anchored" data-anchor-id="gestión-de-variables-dicotómicas">Gestión de variables dicotómicas</h3>
<p>Decíamos que el modelo con enlace <em>logit</em> es un modelo de regresión típico:</p>
<p><span class="math display">\[
Y = f(X + E)
\]</span></p>
<p>donde la variable respuesta (variable aleatoria <span class="math inline">\(Y\)</span>) es dicotómica o binaria (toma dos valores: 0 y 1), habitualmente sobre si nuestra unidad de análisis tiene una característica (1) o no la tiene (0).</p>
<p>Nuestras variables dicotómicas pueden tener originalmente formatos variados y sus categorías también pueden definirse con etiquetas diferentes. Por ejemplo, podemos tener variables dicotómicas con formato lógico (+/-, <code>TRUE</code>/<code>FALSE</code>), con formato caracter (Si/No, Vivo/Muerto, etc.) o con formato numérico codificado (0-1, 1-2 o cualquier combinación personalizada de códigos).</p>
<p>En R las variables categóricas que utilizamos como dependientes en estos modelos corresponden convenientemente al tipo de datos <code>factor</code>. Recordemos que un factor es, interna y técnicamente, una variable numérica compuesta de enteros sucesivos a partir de 1. Cada entero es un nivel o categoría de la variable y está acompañado de una etiqueta que nos facilita recordar a qué categoría corresponde.</p>
<p>Los modelos binomiales asumen las variables dicotómicas codificándolas como 0 y 1, lo cuál podría ser problemático si, como numéricos, los factores comienzan con 1. Como la estructura de los factores es conocida por las funciones que estiman modelos <em>logit</em>, estas funciones convierten internamente la variable categórica/factor en una variable codificada como 0/1, sin que el usuario tenga que hacer nada.</p>
<p>Por lo tanto, no es necesario recodificar la variable o convertirla en <em>dummy</em>, esto se procesa de manera transparente para el usuario. Lo único que debemos asegurarnos es que la variable sea factor y que el <strong>nivel de referencia</strong> sea la <strong>ausencia de la característica</strong> (por ejemplo, enfermedad = No).</p>
<p>Debemos usar la función <code>levels()</code> de R <code>base</code> para consultar los niveles o categorías de un factor e identificar el primer nivel del factor, que será el nivel de referencia en el modelo, es decir, <span class="math inline">\(Y=0\)</span>.</p>
<p>Podemos modificar estos niveles de referencia mediante la función <code>relevel()</code> de R <code>base</code> o con <code>fct_rev()</code> de <code>tidyverse</code>, cuando estos se encuentren invertidos.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Factor con dos categorías</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>factor <span class="ot">&lt;-</span> <span class="fu">factor</span>(<span class="fu">c</span>(<span class="st">"1"</span>, <span class="st">"0"</span>, <span class="st">"1"</span>, <span class="st">"1"</span>, <span class="st">"0"</span>))</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Cambio nivel de referencia en R base</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="fu">relevel</span>(factor, <span class="at">ref =</span> <span class="st">"1"</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1 0 1 1 0
Levels: 1 0</code></pre>
</div>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Cambio nivel de referencia en tidyverse</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fct_rev</span>(factor)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1 0 1 1 0
Levels: 1 0</code></pre>
</div>
</div>
<p>Este procesamiento es extensivo a las variables categóricas (dicotómica o politómicas) que se incluyen en los modelos de regresión como explicativas. En <code>tidyverse</code>, podemos cambiar los niveles de referencia de un factor con más de dos categorías con la función <code>fct_relevel()</code>.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Factor con más de dos categorías</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>factor <span class="ot">&lt;-</span> <span class="fu">factor</span>(<span class="fu">c</span>(<span class="st">"CONF"</span>, <span class="st">"DESC"</span>, <span class="st">"SOSP"</span>, <span class="st">"CONF"</span>, <span class="st">"DESC"</span>, <span class="st">"PROB"</span>))</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Niveles por defecto</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="fu">levels</span>(factor)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "CONF" "DESC" "PROB" "SOSP"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Pongo DESC como nivel de referencia</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fct_relevel</span>(factor, <span class="st">"DESC"</span>, <span class="at">after =</span> <span class="dv">0</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] CONF DESC SOSP CONF DESC PROB
Levels: DESC CONF PROB SOSP</code></pre>
</div>
</div>
</section>
<section id="ajuste-del-modelo" class="level3">
<h3 class="anchored" data-anchor-id="ajuste-del-modelo">Ajuste del modelo</h3>
<p>La razón de verosimilitud en un modelo de regresión puede calcularse restando la devianza del modelo con predictores de la del modelo nulo:</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>modelo<span class="sc">$</span>null.deviance <span class="sc">-</span> modelo<span class="sc">$</span>deviance</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 55.60009</code></pre>
</div>
</div>
<p>En este cálculo, estamos comparando la <em>null deviance</em> (modelo sin predictores) con la <em>residual deviance</em> (modelo con predictores). Alternativamente, la función <code>anova()</code> proporciona una tabla detallada que desglosa la contribución de cada variable al modelo junto con sus respectivas devianzas.</p>
<div class="cell" data-layout-align="center">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">anova</span>(modelo)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Analysis of Deviance Table

Model: binomial, link: logit

Response: y

Terms added sequentially (first to last)

     Df Deviance Resid. Df Resid. Dev  Pr(&gt;Chi)    
NULL                   199     277.08              
x1    2    4.080       197     273.00    0.1301    
x2    1   51.521       196     221.48 7.085e-13 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</code></pre>
</div>
</div>
<p>En un modelo con múltiples predictores, no todas las variables necesariamente aportan información relevante. Identificar y excluir aquellas con menor impacto puede simplificar el modelo sin comprometer su capacidad predictiva. Es fundamental definir qué se entiende por “variable relevante”, ya que la importancia de una variable no debe evaluarse únicamente desde el punto de vista estadístico. El marco conceptual es clave en la selección de predictores, especialmente cuando el objetivo del modelo es analítico. La decisión debe basarse tanto en el conocimiento del área de estudio como en la evidencia estadística.</p>
<p>Un error común es suponer que los métodos estadísticos pueden sustituir el conocimiento sustantivo del problema. El abuso de modelos de regresión sin una adecuada justificación teórica puede llevar a asociaciones espurias o a resultados estadísticamente significativos pero clínicamente, biológicamente o socialmente irrelevantes.</p>
<p>Existen diversos métodos estadísticos para la selección de variables en regresión logística. Estos buscan lograr un modelo parsimonioso que se ajuste bien a los datos sin incluir predictores innecesarios. Si bien estos procedimientos son similares a los utilizados en regresión lineal múltiple, algunos criterios de selección específicos varían.</p>


</section>
</section>

<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Volver arriba</a></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>